<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mochieer.techの新着記事</title>
    <link>https://mochieer.tech</link>
    <description>mochieer.techの新着記事</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>(c) mochieer</copyright>
    <lastBuildDate>Tue, 06 Oct 2020 00:00:00 +0000</lastBuildDate>
    <managingEditor>mochieer@gmail.com (mochieer)</managingEditor>
    <atom:link href="https://mochieer.tech/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
        <title>PlantUML 写経</title>
        <link>https://mochieer.tech/posts/20201006-plantuml/</link>
        <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
        <author>mochieer@gmail.com (mochieer)</author>
        <guid>https://mochieer.tech/posts/20201006-plantuml/</guid>
        <description>最近、 PlantUML でクラス図を書くのが楽しい。 特におすすめなのが、コードレビュー時にひとつひとつのクラスを読み終わるたびに手元で PlantUML を書いていく読み方で</description>
        <content:encoded>&lt;p&gt;最近、 PlantUML でクラス図を書くのが楽しい。&lt;/p&gt;
&lt;p&gt;特におすすめなのが、コードレビュー時にひとつひとつのクラスを読み終わるたびに手元で PlantUML を書いていく読み方で、「PlantUML 写経」と個人的に呼んでいる。&lt;/p&gt;
&lt;p&gt;書いたほうがいいのは、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パッケージ（名前空間）&lt;/li&gt;
&lt;li&gt;クラス
&lt;ul&gt;
&lt;li&gt;private なものは書かなくて良い&lt;/li&gt;
&lt;li&gt;public なものも、別に全部書く必要はない&lt;/li&gt;
&lt;li&gt;abstract は書いておくとよい&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依存関係
&lt;ul&gt;
&lt;li&gt;継承、実装&lt;/li&gt;
&lt;li&gt;ほかの関係
&lt;ul&gt;
&lt;li&gt;クラス A はクラス B のインスタンスを保持する
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;1:1&amp;rdquo;, &amp;ldquo;1:1..n&amp;rdquo;, &amp;ldquo;1:0..n&amp;rdquo; などラベルをつける&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;クラス A はクラス B を利用する（ &amp;ldquo;use&amp;rdquo; とラベルを付ける）&lt;/li&gt;
&lt;li&gt;クラス A はクラス B を生成する（ &amp;ldquo;create&amp;rdquo; とラベルを付ける）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ただし、厳密にすべてを書く必要はない。このように実装せよという指示書ではないのだから。&lt;/p&gt;
&lt;p&gt;たとえば、依存関係が推移的に予想できるところなんかは省略すると読みやすくて良い。 &lt;code&gt;class A implements AInterface&lt;/code&gt; と &lt;code&gt;class B implements BInterface&lt;/code&gt; があり、 AInterface が BInterface に依存していて A が B に依存しているとき、全部書くとややこしくなってしまう。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;PlantUML は incremental に書ける点がよい。&lt;/p&gt;
&lt;p&gt;初見のコードを読みながら紙にクラスの依存関係を手書きすると、だいたい最初に読んだクラスを書く場所が悪くて、後で読んだクラスが紙の端に追いやられ、依存関係の線がぐちゃぐちゃになる。&lt;/p&gt;
&lt;p&gt;PlantUML では、今読んだところまでとりあえず書いておけば、そのときの最善な配置で図を書き出してくれるので、どのクラスから書き始めればいいだろうという悩みはない。&lt;/p&gt;
&lt;p&gt;また、レビューコメントを受けて修正されたりすると、その修正どおりに PlantUML も書き直せば最新のクラス図ができあがる。レビューのお供にとても良い。&lt;/p&gt;
&lt;p&gt;また、依存関係が適切に整理されたコードは、 PlantUML でクラス図を作った時にも、依存が上から下に流れるように描画されてとても美しい。コードを視覚的に堪能することが出来る。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;エディタは使いやすいので良いと思うが、個人的には &lt;a href=&#34;https://boostnote.io/&#34;&gt;Boost Note&lt;/a&gt; の &lt;a href=&#34;https://github.com/BoostIO/boost-releases/releases/tag/v0.16.1&#34;&gt;Legacy App&lt;/a&gt; を使っている。（以前、新しい方を入れたら PlantUML 書けなかったので）&lt;/p&gt;
&lt;p&gt;書いてる時にリアルタイムに図が更新される必要はない（むしろ視線を持っていかれるのでやめてほしい）が、図に反映されるのは簡単で速いのがいい、となって Boost Note に落ち着いている。&lt;/p&gt;
&lt;p&gt;もともと Markdown エディタなので、 PR コメントの下書きも書けて便利。&lt;/p&gt;
</content:encoded>
      </item><item>
        <title>超音波を使ったアプリをリリースして思ったこと</title>
        <link>https://mochieer.tech/posts/20160813-release-ultrasound-app/</link>
        <pubDate>Sat, 13 Aug 2016 00:00:00 +0000</pubDate>
        <author>mochieer@gmail.com (mochieer)</author>
        <guid>https://mochieer.tech/posts/20160813-release-ultrasound-app/</guid>
        <description>アプリの概要 ワンタップでその場の全員と Facebook アカウントを交換できる iOS アプリ「Hz」をリリースした（一週間くらい前に）。 アプリのコンセプトは、Fa</description>
        <content:encoded>&lt;figure&gt;&lt;img src=&#34;https://mochieer.tech/posts/20160813-release-ultrasound-app/cover.jpg&#34; alt=&#34;Hzをリリースしました&#34; /&gt;&lt;/figure&gt;
&lt;h2 id=&#34;アプリの概要&#34;&gt;アプリの概要&lt;/h2&gt;
&lt;p&gt;ワンタップでその場の全員と Facebook アカウントを交換できる iOS アプリ「Hz」をリリースした（一週間くらい前に）。&lt;/p&gt;
&lt;p&gt;アプリのコンセプトは、Facebook アカウント交換の煩わしさをボタンひとつで済ませられるようにするというところ。&lt;/p&gt;
&lt;p&gt;その場に何人いても、誰か一人がボタンをワンタップするだけなので、特に飲み会などの席で役に立つと思う。&lt;/p&gt;
&lt;p&gt;詳細は下記 LP と、一緒に作った pika_shi の記事がアツい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://hz.matataki.team/&#34;&gt;Hz (ヘルツ) - 5 秒でその場の全員とつながる Facebook アカウント交換アプリ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pika-shi.hatenablog.com/entry/2016/08/07/152528&#34;&gt;Facebook アカウント交換アプリ「Hz」をリリースした - Hello World!!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自分はアカウント交換のコアロジックとデザインを担当した。&lt;/p&gt;
&lt;h2 id=&#34;超音波&#34;&gt;超音波&lt;/h2&gt;
&lt;p&gt;Hz では、端末のペアリングに超音波による通信技術を利用した。&lt;/p&gt;
&lt;p&gt;超音波通信技術なんていうとかなり細かいことをやっているのかと思われるかもしれないが、端末から非可聴域の高周波な音を出し、別の端末では常に FFT を回し続けるだけなので、シンプルといえばシンプル。&lt;/p&gt;
&lt;p&gt;ただ、思考の順序としては実は逆で、先に iOS で超音波で通信できることを調べてから、「じゃあ、これ何に使えるか」と考えて Facebook アカウント交換アプリという形になった。&lt;/p&gt;
&lt;p&gt;アイデアをまとめていく過程、実装する過程で気づいた超音波による信号通信の長所と短所をまとめておく。&lt;/p&gt;
&lt;h3 id=&#34;長所&#34;&gt;長所&lt;/h3&gt;
&lt;h4 id=&#34;高速&#34;&gt;高速&lt;/h4&gt;
&lt;p&gt;インターネット通信をしないというメリットはすごく大きい。単に音を出す、音を聞くだけなので、通信のオーバーヘッドはほぼゼロと言える。Bluetooth なども一旦ペアリングしてしまえば強力だが、ペアリングは手間だったりする。&lt;/p&gt;
&lt;h4 id=&#34;デバイスに依存しない&#34;&gt;デバイスに依存しない&lt;/h4&gt;
&lt;p&gt;発信に必要なのはスピーカーだけ。受信に必要なのはマイクと FFT が行えるくらいのメモリとプロセッサだけ。お店に設置したスピーカーから超音波を出して、キャッチしたアプリにクーポンを表示する、とかもできる。&lt;/p&gt;
&lt;h4 id=&#34;ブロードキャストできる&#34;&gt;ブロードキャストできる&lt;/h4&gt;
&lt;p&gt;1対1の通信でなく、1対Nの通信を1度に行える。スタジアムの大きいスピーカーを使えば、スポーツ観戦している人全員に一斉に信号を配信することも理論上は可能。&lt;/p&gt;
&lt;h4 id=&#34;通信範囲を空間で区切れる&#34;&gt;通信範囲を「空間」で区切れる&lt;/h4&gt;
&lt;p&gt;超音波は音に過ぎないので、隣の部屋までは飛んでいかない。「この部屋に入ってきた」ということを、電波や GPS より明確に区別できる。&lt;/p&gt;
&lt;h4 id=&#34;電子機器に影響しない&#34;&gt;電子機器に影響しない&lt;/h4&gt;
&lt;p&gt;繰り返しになるが、超音波は音に過ぎないので、他の電子機器への干渉はほぼない。特に精密機械が多い医療分野への貢献はあるかもしれない。&lt;/p&gt;
&lt;h3 id=&#34;短所&#34;&gt;短所&lt;/h3&gt;
&lt;h4 id=&#34;通信できる情報が少ない&#34;&gt;通信できる情報が少ない&lt;/h4&gt;
&lt;p&gt;PIN コードを送るくらいが限度。テキストを送るとなると、相当うまく作らないと HTTP のほうが高速になってくると思う。&lt;/p&gt;
&lt;h4 id=&#34;帯域が狭い&#34;&gt;帯域が狭い&lt;/h4&gt;
&lt;p&gt;デバイスのサンプリング周波数に依存するところだが、FFT で判別できる周波数には上限がある。なので、仮に超音波が街中いろんなところで使われるようなことになったとしたら、帯域が競合してしまうことになる。同じ理由で、同じロジックを持ったプロダクトが世の中に共存できないので、基本的に超音波通信の OSS というのも考えにくい。&lt;/p&gt;
&lt;h4 id=&#34;セキュリティが脆弱すぎる&#34;&gt;セキュリティが脆弱すぎる&lt;/h4&gt;
&lt;p&gt;単にマイクがあれば通信傍受できてしまう。傍受して信号を解析すると（信号も単純なので解析は容易）、あとはスピーカーがあるだけで操作もできてしまう。&lt;/p&gt;
&lt;p&gt;と、こんな感じ。&lt;/p&gt;
&lt;p&gt;長所も多いが短所も多い。ただ、引き出しとしてひとつ持っておくと、なにか面白いことができるかも？&lt;/p&gt;
</content:encoded>
      </item>
  </channel>
</rss>
